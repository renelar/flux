y <- makeVector(1)
y
z <- y$get()
z
gget <- function() x
gget
gget(x)
gget(1)
x <- 3
gget
gget(1)
gget(x)
$gget
y <- gget
y
y <- gget()
y
z <- sample(10)
z
y$set(z)
y <- makeVector(1)
y$set(z)
y$get()
y
makeCacheMatrix <- function(x) {
# Matrix inversion is usually a costly computation and there may be some
# benefit to caching the inverse of a matrix rather than compute it
# repeatedly. This function creates a special "matrix" object that
# can cache its inverse.
#
# Args:
#   ma: Matrix; A square matrix that is invertible.
# Returns:
#   A numeric vector of correlations.
#
ma     <- x
ma.inv <- NULL
set <- function(y) {
ma     <<- y
ma.inv <<- NULL
}
get <- function() {ma}
}
z <- matrix(sample(4), 2, 2)
z
f <- makeCacheMatrix(z)
f
makeCacheMatrix <- function(x) {
# Matrix inversion is usually a costly computation and there may be some
# benefit to caching the inverse of a matrix rather than compute it
# repeatedly. This function creates a special "matrix" object that
# can cache its inverse.
#
# Args:
#   ma: Matrix; A square matrix that is invertible.
# Returns:
#   A numeric vector of correlations.
#
ma     <- x
ma.inv <- NULL
set <- function(y) {
ma     <<- y
ma.inv <<- NULL
}
get <- function() ma
list(set = set, get = get)
}
z <- matrix(sample(4), 2, 2)
z
f <- makeCacheMatrix(z)
f
f$get()
z2 <- matrix(sample(9), 3, 3)
f$set(z2)
f$get()
class(z2)
makeCacheMatrix <- function(x) {
# Matrix inversion is usually a costly computation and there may be some
# benefit to caching the inverse of a matrix rather than compute it
# repeatedly. This function creates a special "matrix" object that
# can cache its inverse.
#
# Args:
#   ma: Matrix; A square matrix that is invertible.
# Returns:
#   A numeric vector of correlations.
#
ma     <- x
ma.inv <- NULL
set <- function(y) {
ma     <<- y
ma.inv <<- NULL
}
get <- function() ma
set.inv <- function(i) {ma.inv <<- i}
get.inv <- function()  {ma.inv}
list(set = set, get = get,
set.inv = set.inv, get.inv = get.inv)
}
cacheSolve <- function(c) {
# Computes the inverse of a special matrix returned by the makeCacheMatrix
# function. If the inverse has already been calculated (and the matrix
# has not changed), then cacheSolve should retrieve the inverse from
# the cache.
#
# NOTE: Non-square matrices do not have inverses; this function checks
# that that the matrix supplied is invertible. Use the
# matrix(sample(4), 2, 2) or matrix(sample(9), 3, 3) statement for
# testing.
#
# Args:
#   ma: Matrix; A square matrix that is invertible.
if (c$get.inv() == NULL) {
ma.inv <- solve(ma)
}
else {
ma.inv
}
}
z1 <- matrix(sample(4), 2, 2)
f <- makeCacheMatrix(z1)
f$get()
cacheSolve(f)
cacheSolve <- function(c) {
# Computes the inverse of a special matrix returned by the makeCacheMatrix
# function. If the inverse has already been calculated (and the matrix
# has not changed), then cacheSolve should retrieve the inverse from
# the cache.
#
# NOTE: Non-square matrices do not have inverses; this function checks
# that that the matrix supplied is invertible. Use the
# matrix(sample(4), 2, 2) or matrix(sample(9), 3, 3) statement for
# testing.
#
# Args:
#   ma: Matrix; A square matrix that is invertible.
mt <- c$get.inv()
if (!is.null()) {
ma.inv <- solve(ma)
}
else {
ma.inv
}
}
cacheSolve(f)
cacheSolve <- function(c) {
# Computes the inverse of a special matrix returned by the makeCacheMatrix
# function. If the inverse has already been calculated (and the matrix
# has not changed), then cacheSolve should retrieve the inverse from
# the cache.
#
# NOTE: Non-square matrices do not have inverses; this function checks
# that that the matrix supplied is invertible. Use the
# matrix(sample(4), 2, 2) or matrix(sample(9), 3, 3) statement for
# testing.
#
# Args:
#   ma: Matrix; A square matrix that is invertible.
mt <- c$get.inv()
if (!is.null(mt)) {
ma.inv <- solve(ma)
}
else {
ma.inv
}
}
cacheSolve(f)
cacheSolve <- function(c) {
# Computes the inverse of a special matrix returned by the makeCacheMatrix
# function. If the inverse has already been calculated (and the matrix
# has not changed), then cacheSolve should retrieve the inverse from
# the cache.
#
# NOTE: Non-square matrices do not have inverses; this function checks
# that that the matrix supplied is invertible. Use the
# matrix(sample(4), 2, 2) or matrix(sample(9), 3, 3) statement for
# testing.
#
# Args:
#   ma: Matrix; A square matrix that is invertible.
mt <- c$get.inv()
if (!is.null(mt)) {
c$set.inv <- solve(c$get())
}
else {
c$get.inv
}
}
cacheSolve(f)
z1 <- matrix(sample(4), 2, 2)
f$get()
cacheSolve(f)
cacheSolve <- function(c) {
# Computes the inverse of a special matrix returned by the makeCacheMatrix
# function. If the inverse has already been calculated (and the matrix
# has not changed), then cacheSolve should retrieve the inverse from
# the cache.
#
# NOTE: Non-square matrices do not have inverses; this function checks
# that that the matrix supplied is invertible. Use the
# matrix(sample(4), 2, 2) or matrix(sample(9), 3, 3) statement for
# testing.
#
# Args:
#   ma: Matrix; A square matrix that is invertible.
mt <- c$get.inv()
if (!is.null(mt)) {
c$set.inv <- solve(c$get())
}
else {
c$get.inv()
}
}
cacheSolve(f)
f$get.inv()
cacheSolve <- function(c) {
# Computes the inverse of a special matrix returned by the makeCacheMatrix
# function. If the inverse has already been calculated (and the matrix
# has not changed), then cacheSolve should retrieve the inverse from
# the cache.
#
# NOTE: Non-square matrices do not have inverses; this function checks
# that that the matrix supplied is invertible. Use the
# matrix(sample(4), 2, 2) or matrix(sample(9), 3, 3) statement for
# testing.
#
# Args:
#   ma: Matrix; A square matrix that is invertible.
mt <- c$get.inv()
if (!is.null(mt)) {
c$set.inv(solve(c$get())
}
else {
c$get.inv()
}
}
cacheSolve <- function(c) {
# Computes the inverse of a special matrix returned by the makeCacheMatrix
# function. If the inverse has already been calculated (and the matrix
# has not changed), then cacheSolve should retrieve the inverse from
# the cache.
#
# NOTE: Non-square matrices do not have inverses; this function checks
# that that the matrix supplied is invertible. Use the
# matrix(sample(4), 2, 2) or matrix(sample(9), 3, 3) statement for
# testing.
#
# Args:
#   ma: Matrix; A square matrix that is invertible.
mt <- c$get.inv()
if (!is.null(mt)) {
c$set.inv(solve(c$get()))
}
else {
c$get.inv()
}
}
cacheSolve(f)
f$get.inv()
z2 <- solve(f$get())
z2
f$set.inv(solve(f$get()))
f$get.inv()
f$set.inv(NULL)
f$get.inv()
f$get()
cacheSolve(f)
?print
cacheSolve <- function(c) {
# Computes the inverse of a special matrix returned by the makeCacheMatrix
# function. If the inverse has already been calculated (and the matrix
# has not changed), then cacheSolve should retrieve the inverse from
# the cache.
#
# NOTE: Non-square matrices do not have inverses; this function checks
# that that the matrix supplied is invertible. Use the
# matrix(sample(4), 2, 2) or matrix(sample(9), 3, 3) statement for
# testing.
#
# Args:
#   ma: Matrix; A square matrix that is invertible.
mt <- c$get.inv()
if (!is.null(mt)) {
print("matrix inverse is NULL")
c$set.inv(solve(c$get()))
}
else {
c$get.inv()
}
}
cacheSolve(f)
cacheSolve <- function(c) {
# Computes the inverse of a special matrix returned by the makeCacheMatrix
# function. If the inverse has already been calculated (and the matrix
# has not changed), then cacheSolve should retrieve the inverse from
# the cache.
#
# NOTE: Non-square matrices do not have inverses; this function checks
# that that the matrix supplied is invertible. Use the
# matrix(sample(4), 2, 2) or matrix(sample(9), 3, 3) statement for
# testing.
#
# Args:
#   ma: Matrix; A square matrix that is invertible.
mt <- c$get.inv()
if (!is.null(mt)) {
print("matrix inverse is NULL")
c$set.inv(solve(c$get()))
}
else {
print("matrix inverse is not NULL")
c$get.inv()
}
}
cacheSolve(f)
f$set.inv(NULL)
cacheSolve(f)
f$get.inv()
cacheSolve <- function(c) {
# Computes the inverse of a special matrix returned by the makeCacheMatrix
# function. If the inverse has already been calculated (and the matrix
# has not changed), then cacheSolve should retrieve the inverse from
# the cache.
#
# NOTE: Non-square matrices do not have inverses; this function checks
# that that the matrix supplied is invertible. Use the
# matrix(sample(4), 2, 2) or matrix(sample(9), 3, 3) statement for
# testing.
#
# Args:
#   ma: Matrix; A square matrix that is invertible.
mt <- c$get.inv()
print("mt var = ", mt)
if (!is.null(mt)) {
print("matrix inverse is NULL")
c$set.inv(solve(c$get()))
}
else {
print("matrix inverse is not NULL")
c$get.inv()
}
}
f$get.inv()
cacheSolve(f)
cacheSolve <- function(c) {
# Computes the inverse of a special matrix returned by the makeCacheMatrix
# function. If the inverse has already been calculated (and the matrix
# has not changed), then cacheSolve should retrieve the inverse from
# the cache.
#
# NOTE: Non-square matrices do not have inverses; this function checks
# that that the matrix supplied is invertible. Use the
# matrix(sample(4), 2, 2) or matrix(sample(9), 3, 3) statement for
# testing.
#
# Args:
#   ma: Matrix; A square matrix that is invertible.
mt <- c$get.inv()
print("mt var = ", mt)
if (is.null(mt)) {
print("matrix inverse is NULL")
c$set.inv(solve(c$get()))
}
else {
print("matrix inverse is not NULL")
c$get.inv()
}
}
cacheSolve(f)
f$get.inv()
z1 <= matrix(sample(9), 3, 3)
z1 <= matrix(sample(9), 3, 3)
z1 <= matrix(sample(4), 2, 2)
z1 <- matrix(sample(9), 3, 3)
z2 <- matrix(sample(9), 3, 3)
z1
z2
i1 <- solve(z1)
i2 <- solve(z2)
i1 == i2
i1 = i2
z1 <- matrix(sample(9), 3, 3)
z2 <- matrix(sample(9), 3, 3)
i1 <- solve(z1)
i2 <- solve(z2)
identical(i1, i2)
i1
i2
identical(i1, i2)
makeCacheMatrix <- function(mx1) {
# Matrix inversion is usually a costly computation and there may be some
# benefit to caching the inverse of a matrix rather than compute it
# repeatedly. This function creates a special "matrix" object that
# can cache its inverse.
#
# Args:
#   ma: Matrix; A square matrix that is invertible.
# Returns:
#   $set(mx1) returns the A numeric vector of correlations.
mx     <- x
mx.inv <- NULL
set <- function(mx1) {
mx.inv <<- NULL
mx     <<- mx1
TRUE
}
get <- function() {mx}
setInverse <- function(i) {mx.inv <<- i}
getInverse <- function()  {mx.inv}
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
cacheSolve <- function(mCM) {
# Computes the inverse of a special matrix returned by the makeCacheMatrix
# function. If the inverse has already been calculated (and the matrix
# has not changed), then cacheSolve should retrieve the inverse from
# the cache.
#
# NOTE: Non-square matrices do not have inverses; this function checks
# that that the matrix supplied is invertible. Use the
# matrix(sample(4), 2, 2) or matrix(sample(9), 3, 3) statement for
# testing.
#
# Args:
#   cma: Function; A square matrix that is invertible.
mx <- mCM$getInverse()  # Retrieve the inverted matrix
# If the variable is null, invert the cached matrix
# and store it in the object.
if (is.null(mx)) {
mCM$setInverse(solve(mCM$get()))
}
# If the object already has an inverted matrix, return that matrix
else {
mCM$getInverse()
}
}
z1 <- matrix(sample(9), 3, 3)
f <- makeCacheMatrix(z1)
f
f$getInverse()
f$get()
z1
f <- makeCacheMatrix(z1)
f$get()
f$set(z1)
f$get()
cacheSolve(f)
f$getInverse()
f$get()
z1 <- matrix(sample(9), 3, 3)
f <- makeCacheMatrix()
f$get()
f$set(z1)
makeCacheMatrix <- function(mx1 = NULL) {
# Matrix inversion is usually a costly computation and there may be some
# benefit to caching the inverse of a matrix rather than compute it
# repeatedly. This function creates a special "matrix" object that
# can cache its inverse.
#
# Args:
#   ma: Matrix; A square matrix that is invertible.
# Returns:
#   $set(mx1) returns the A numeric vector of correlations.
mx     <- mx1
mx.inv <- NULL
set <- function(mx1) {
mx.inv <<- NULL
mx     <<- mx1
}
get <- function() {mx}
setInverse <- function(i) {mx.inv <<- i}
getInverse <- function()  {mx.inv}
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
cacheSolve <- function(mCM) {
# Computes the inverse of a special matrix returned by the makeCacheMatrix
# function. If the inverse has already been calculated (and the matrix
# has not changed), then cacheSolve should retrieve the inverse from
# the cache.
#
# NOTE: Non-square matrices do not have inverses; this function checks
# that that the matrix supplied is invertible. Use the
# matrix(sample(4), 2, 2) or matrix(sample(9), 3, 3) statement for
# testing.
#
# Args:
#   cma: Function; A square matrix that is invertible.
mx <- mCM$getInverse()  # Retrieve the inverted matrix
# If the variable is null, invert the cached matrix
# and store it in the object.
if (is.null(mx)) {
mCM$setInverse(solve(mCM$get()))
}
# If the object already has an inverted matrix, return that matrix
else {
mCM$getInverse()
}
}
z1 <- matrix(sample(9), 3, 3)
f <- makeCacheMatrix()
f$get()
f$set(z1)
f$get()
f$getInverse()
cacheSolve(f)
f$getInverse()
z2 <- matrix(sample(9), 3, 3)
f$set(z2)
f$getInverse()
